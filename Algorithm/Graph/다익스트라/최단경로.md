# 최단경로

[최단경로](https://www.acmicpc.net/problem/1753)

## 개념
+ 다른 모든 노드까지의 최단거리를 구해야하므로 다익스트라 이용 
+ 인접리스트에 노드 저장
+ 최초 시작점(K) 우선순위큐에 삽입
+ 다익스트라 알고리즘 수행
  + 거리 배열에서 아직 방문하지 않은 노드 중 현재 값(거리)이 가장 작은 노드 선택
    + [연결노드 거리 리스트값] > [선택노드 거리 리스트값 + 에지 가중치]가 더 작은 경우 업데이트 수행
    + 업데이트가 수행된 경우 연결노드를 우선순위 큐에 삽입
+ 완성된 거리 배열 값 출력 
+ 우선순위 큐에 현재 값(거리)이 가장 작은 순으로 삽입해야함 
  + CompareTo()함수 이용해서 정렬기준 정의
    ```java
    class Edge implements Comparable<Edge>{
        int vertex, value;
        Edge(int vertex, int value){
            this.vertex = vertex;
            this.value = value;
        }

        public int compareTo(Edge e){
            if(this.value > e.value){
                return 1;
            }else{
                return -1;
            }
        }
    }
    ```

## 풀이
```java
import java.util.*;
import java.io.*;

class Main{
    static int V,E,K;
    static int[] distance;
    static boolean visited[];
    static ArrayList<Edge> list[];
    static PriorityQueue<Edge> q = new PriorityQueue<Edge>();

    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        V = Integer.parseInt(st.nextToken());
        E = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        K = Integer.parseInt(st.nextToken());

        distance = new int[V+1];
        visited = new boolean[V+1];
        list = new ArrayList[V+1];

        for(int i =1; i < V+1; i++){
            list[i] = new ArrayList<Edge>();
        }

        for(int i =0; i <= V; i++){
            distance[i] = Integer.MAX_VALUE;
        }

        for( int i =0; i <E; i++){
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            list[u].add(new Edge(v,w));
        }

        q.add(new Edge(K,0));

        distance[K] = 0;

        while(!q.isEmpty()){
            Edge cur = q.poll();
            int c_v = cur.vertex;
            if(visited[c_v]) continue;
            visited[c_v] = true;
            for( int i=0; i <list[c_v].size(); i++){
                Edge temp = list[c_v].get(i);
                int next = temp.vertex;
                int value = temp.value;
                if(distance[next] > distance[c_v]+value){
                    distance[next] = distance[c_v]+value;
                    q.add(new Edge(next,distance[next]));
                }
            }
        }

        for(int i =1; i < V+1; i++){
            if(visited[i]){
                System.out.println(distance[i]);
            }else{
                System.out.println("INF");
            }
        }

    }
}
class Edge implements Comparable<Edge>{
    int vertex, value;
    Edge(int vertex, int value){
        this.vertex = vertex;
        this.value = value;
    }

    public int compareTo(Edge e){
        if(this.value > e.value){
            return 1;
        }else{
            return -1;
        }
    }
}
```