# 최소비용 구하기

[최소비용 구하기](https://www.acmicpc.net/problem/1916)

## 개념
+ 다른 모든 노드까지의 최소비용을 구해야하므로 다익스트라 이용 
+ 인접리스트에 노드 저장
+ 최초 시작점(start) 우선순위큐에 삽입
+ 비용[start] = 0 할당 
+ 다익스트라 알고리즘 수행
  + 거리 배열에서 아직 방문하지 않은 노드 중 현재 값(비용)이 가장 작은 노드 선택
    + [연결노드 비용 리스트값] > [선택노드 비용 리스트값 + 에지 가중치]가 더 작은 경우 업데이트 수행
    + 업데이트가 수행된 경우 연결노드를 우선순위 큐에 삽입
+ 완성된 비용 배열 end 값 출력 
+ 우선순위 큐에 현재 값(비용)이 가장 작은 순으로 삽입해야함 


## 풀이
```java
import java.util.*;
import java.io.*;

class Main{
    static int N,M,start, end, v;
    static ArrayList<Edge> list[];
    static boolean[] visited;
    static int[] distance;
    static PriorityQueue<Edge> q = new PriorityQueue<Edge>();

    public static void main(String[] args)throws IOException{

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        M = Integer.parseInt(st.nextToken());

        list = new ArrayList[N+1];
        visited = new boolean[N+1];
        distance = new int[N+1];

        for(int i =1; i <=N; i++){
            list[i] = new ArrayList<Edge>();
        }

        for(int i =0; i <= N; i++){
            distance[i] = Integer.MAX_VALUE;
        }

        for(int i =0; i <M; i++){
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            list[s].add(new Edge(e, v));
        }

        st = new StringTokenizer(br.readLine());
        start = Integer.parseInt(st.nextToken());
        end = Integer.parseInt(st.nextToken());

        q.add(new Edge(start, 0));
        distance[start] = 0;

        while(!q.isEmpty()){
            Edge cur = q.poll();
            if(visited[cur.end]) continue;
            visited[cur.end] = true;
            for(Edge i:list[cur.end]){
                int next_end = i.end;
                int next_value = i.value;

                if(!visited[next_end] && distance[next_end] > distance[cur.end] + next_value){
                    distance[next_end] = distance[cur.end] + next_value;
                    q.add(new Edge(next_end, distance[next_end]));


                }

            }
        }

        System.out.println(distance[end]);


    }
}

class Edge implements Comparable<Edge>{
    int end, value;

    Edge(int end, int value){
        this.end = end;
        this.value = value;
    }

    @Override
    public int compareTo(Edge e){
        return value - e.value;
    }
}
```