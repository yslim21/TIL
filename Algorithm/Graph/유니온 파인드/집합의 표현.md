# 집합의 표현

[집합의 표현](https://www.acmicpc.net/problem/1717)

## 개념
+ 유니온 파인드 이용
+ union
  + 1을 대표노드 4를 자식노드로 union 연산할떄는 배열[4]의 값을 대표 노드값인 1로 변경 
+ find
  1. 대상 노드 배열에 index값과 value값이 동일한지 확인 
  2. 동일하지 않으면 value값이 가리키는 index 위치로 이동
  3. 이동 위치의 index값과 value값이 같을 때까지 1~2 반복 => **재귀함수**로 구현
  4. 대표 노드에 도달하면 재귀함수를 빠져나오면서 거치는 모든 노드값을 대표 노드값으로 변경 



## 풀이
```java
import java.io.*;
import java.util.*;

class Main{
    static int N,M;
    static int[] arr;


    public static void main(String[] args)throws IOException{

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        arr = new int[N+1];

        for(int i =0; i < N+1; i++){
            arr[i] = i;
        }

        for(int i =0; i < M; i++){
            st = new StringTokenizer(br.readLine());
            int q = Integer.parseInt(st.nextToken());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            if(b < a){
                int temp = a;
                a = b;
                b = temp;
            }
            if( q == 0){
                a = find(a);
                b = find(b);
                arr[b] = a;
            }else if( q ==1){
                if(checkSame(a,b)){
                    System.out.println("YES");
                }else{
                    System.out.println("NO");
                }

            }
        }
    }

    static int find(int a){
        if( a == arr[a]){
            return a;
        }else{
            arr[a] = find(arr[a]);
            return arr[a];
        }
    }

    static boolean checkSame(int a, int b){
        a = find(a);
        b = find(b);
        if( a == b){
            return true;
        }else{
            return false;
        }
    }
}
```