# 여행 가자

[여행 가자](https://www.acmicpc.net/problem/1976)

## 개념1
+ dfs이용
+ plan[]에 들어있는 도시들이 dfs후 visited[]에 모두 true로 저장되어있는지 확인
  + 모두 true면 YES 출력
  + 아니면 NO 출력



## 풀이1 - dfs
```java
import java.io.*;
import java.util.*;

class Main{
    static int N,M;
    static int[][] map;
    static boolean visited[];
    static int[] plan;


    public static void main(String[] args)throws IOException{

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        M = Integer.parseInt(st.nextToken());

        map = new int[N+1][N+1];
        visited = new boolean[N+1];
        plan = new int[M];

        for(int i =1; i < N+1; i++){
            st = new StringTokenizer(br.readLine());
            for(int j=1; j < N+1; j++){
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        st = new StringTokenizer(br.readLine());
        for(int i =0; i < M; i++){
            plan[i] = Integer.parseInt(st.nextToken());
        }

        dfs(plan[0]);

        boolean possible = true;
        for(int i =0; i < M; i++){
            if(!visited[plan[i]]){
                possible = false;
                break;
            }
        }

        System.out.println(possible? "YES":"NO");


    }

    static void dfs(int start){

        visited[start] = true;
        for(int next = 1; next < N+1; next++){
            if(map[start][next] == 1 && !visited[next]){
                dfs(next);
            }
        }
    }
}
```

## 개념2
+ 유니온 파인드
+ 도시 배열의 값을 인덱스 값으로 초기화
+ 경로 데이터(map)와 계획 배열 저장
+ 도시 연결 정보가 저장된 인접 행렬을 탐색하면서 도시과 연결돼 있을 때 union 연산 수행 
+ 계획 배열에 있는 도시들의 대표노드가 모두 같은지 확인 -> 대표 노드가 모두 같더라도 현재 Parent배열에 반영이 안되어있을 수 있으므로 대표노드가 같은지 비교할때는 대표노드 찾기를 한 후 비교!! 



## 풀이2 - 유니온 파인드
```java
import java.io.*;
import java.util.*;

class Main{
    static int N,M;
    static int[][] map;
    static int[] parent;
    static int[] plan;


    public static void main(String[] args)throws IOException{

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        M = Integer.parseInt(st.nextToken());

        map = new int[N+1][N+1];
        parent = new int[N+1];
        plan = new int[M];

        for(int i =1; i < N+1; i++){
            parent[i] =i;
        }

        for(int i =1; i < N+1; i++){
            st = new StringTokenizer(br.readLine());
            for(int j=1; j < N+1; j++){
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        for(int i =1; i < N+1; i++){
            for(int j=1; j < N+1; j++){
                if(map[i][j] ==1){
                    union(i,j);
                }
            }
        }

        st = new StringTokenizer(br.readLine());
        for(int i =0; i < M; i++){
            plan[i] = Integer.parseInt(st.nextToken());
        }

        //여행 계획 도시들이 1개의 대표 도시로 연결되어있는지 확인
        int start = find(plan[0]);
        boolean possible = true;
        for(int i =1; i < M; i++){
            if(find(plan[i] != start){
                System.out.println("NO");
                return;
            }
        }

        System.out.println("YES");

    }

    static void union(int a,int b){
        a = find(a);
        b = find(b);
        if(a!=b){
            parent[b] = a;
        }
    }

    static int find(int a){
        if(a==parent[a]){
            return a;
        }else{
            parent[a] = find(parent[a]);
            return parent[a];
        }
    }
}
```