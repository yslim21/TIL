# 가장 긴 짝수 연속한 부분 수열  
[가장 긴 짝수 연속한 부분 수열](https://www.acmicpc.net/problem/22862)

## 개념
+ 투포인터 이용
+ 두개의 포인터를 이용하는데 
  + start: 부분 수열의 시작 지점
  + cur : 부분 수열의 현재 지점 
+ 현재지점이 N을 넘어서면 끝까지 탐색한 것이므로 while문 종료
+ 홀수를 제거할 기회가 있는 경우
  + 홀수 제거할 기회 사용
  + cur을 증가시키고 부분수열 최대 길이 갱신
+ 홀수를 제거할 기회는 없지만 이번 수가 짝수
  + cur을 증가시키고 부분수열 최대 길이 갱신
+ 홀수를 제거할 기회가 없고 이번 수가 홀수
  + 현재 부분 수열의 시작 지점이 홀수라면 홀수 제거 기회 다시 획득 
  + 부분 수열의 시작 지점을 하나 증가
    + start가 홀수 였으면 제거된 홀수를 부분 수열에 포함시키지 않음으로써 홀수 제거 기회를 하나 더 획득한것
    + start가 짝수였으면 홀수 제거 기회 획득 없이 다음 부분 수열을 탐색하게된것 

## 풀이
```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());
        
        boolean[] arr = new boolean[N];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            int num = Integer.parseInt(st.nextToken());
            arr[i] = num % 2 == 0; //짝수인지 아닌지 배열에 체크 
        }
        
        int count =0; 
        int max = 0; 
        int cur =0; 
        int start = 0; 
        while(cur < N){
            if(count < K ){ // 제거 기회가 있고 
                if(!arr[cur]){ // 홀수면 
                    count++; //홀수 제거 사용 
                }
                cur++; //다음 수로 넘어가기 
                max = Math.max(cur-start-count, max); // 
            }
            else if(arr[cur]){ // 제거 기회가 없고 짝수면
                cur++; //다음수로 넘거가기 
                max = Math.max(cur-start-count, max);
            }else{ // 제거 기회가 없고 홀수면 
                if(!arr[start]){  //start가 현재 홀수면 
                    count--; // 홀수 제거 기회 다시 획득 
                }
                start++;  // start는 이제 다음칸으로 이동 
            }
        }
        System.out.println(max); // 연속한 짝수 부분 수열 중 가장 긴 길이 출력 
    }
}
```