# 버블 소트
[버블 소트](https://www.acmicpc.net/problem/1517)

## 개념
+ 기존 병합 정렬을 이용함
+ 이때, swap이 일어난 횟수를 출력하면되는데 뒤쪽 데이터 값이 더 작아 선택할 때 swap이 일어났다고 가정하고, 이동한 거리만큼 결과값에 더하기


## 풀이
```java
import java.util.*;
import java.io.*;

class Main{
    public static int N;
    public static int[] arr, tmp; 
    public static long result; 
    public static void main(String[] args) throws IOException{
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        
        N = Integer.parseInt(st.nextToken());
        arr = new int[N+1];
        tmp = new int[N+1];
        
        st = new StringTokenizer(br.readLine(), " ");
        for(int i =1; i < N+1; i++){
            arr[i] = Integer.parseInt(st.nextToken());
        }
        
        sort(1,N);
        System.out.println(result);
    }
    
    public static void sort(int s, int e){
        if(e-s < 1){
            return; 
        }
        int m = (s+e)/2;
        
        sort(s,m);
        sort(m+1,e);
        
        for(int i =s; i <= e; i++){
            tmp[i] = arr[i];
        }
        
        int k =s;
        int index1 = s;
        int index2 = m+1; 
        
        while(index1 <= m && index2 <=e){
            if(tmp[index1] > tmp[index2]){
                arr[k] = tmp[index2];
                result += index2 - k;
                k++;
                index2++;
            }else{
                arr[k] = tmp[index1];
                k++;
                index1++;
            }
        }
        
        while(index1 <=m){
            arr[k] = tmp[index1];
            k++;
            index1++;
        }
        
        while(index2 <=e){
            arr[k] = tmp[index2];
            k++;
            index2++;
        }
    }
}
```