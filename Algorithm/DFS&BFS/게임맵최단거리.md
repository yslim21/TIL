# 게임 맵 최단거리

[게임 맵 최단거리](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

## 개념
+ BFS 이용
+ 출발칸이 벽으로 막힌 경우 & 도착지가 벽으로 둘러쌓인 경우만 -1 return하도록 예외처리했는데, 1x3같은 경우에는 2번쨰칸이 벽이어도 도착지 주변 3칸이 벽이 아니므로 해당 예외에 걸리지 않아 에러남 => bfs 끝났는데 도착지가 그대로 1인 경우만 -1 return 하도록 변경 

## 풀이
```java
import java.io.*;
import java.util.*;

class Solution {
 
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1}; 

    static class Point {
        int x;
        int y;
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public int solution(int[][] maps) {
        int answer = 0;
        int n = maps.length;      
        int m = maps[0].length;
        
        boolean visited[][] = new boolean[n][m];
        
        // if((maps[n-2][m-1] == 0 && maps[n-2][n-2] == 0 && maps[n-1][n-2] ==0) || maps[0][0] == 0){
        //     return -1;
        // }
        
        
        Queue<Point> queue = new LinkedList<Point>();
        
        queue.offer(new Point(0,0));
        visited[0][0] = true; 
        
        while(!queue.isEmpty()){
            Point start = queue.poll();
            
            for(int i=0; i < 4; i++){
                int nextx = start.x + dx[i];
                int nexty = start.y + dy[i];
                
                if(nextx < 0 || nextx >= n || nexty < 0 || nexty >= m){
                    continue; 
                }
                if(!visited[nextx][nexty] && maps[nextx][nexty] == 1){
                    queue.offer(new Point(nextx,nexty));
                    visited[nextx][nexty] = true;
                    maps[nextx][nexty] = maps[start.x][start.y] + 1; 
                    
                }
            }
        }
        //answer = maps[n-1][m-1];
        
        return (maps[n-1][m-1] == 1) ? -1 : maps[n-1][m-1];
    }
    
}
```