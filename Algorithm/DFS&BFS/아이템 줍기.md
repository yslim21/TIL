# 아이템 줍기

[아이템 줍기](https://school.programmers.co.kr/learn/courses/30/lessons/87694)

## 개념
+ 최단거리 구하기 이므로 BFS 사용
+ 사각형 돌면서 테두리는 2 , 사각형 내부는 1로 표시
  + 이때 사각형 좌표들을 2배로 크게 잡아서 표시하자 
    + 케이스1번의 (3,5)좌표에서처럼 bfs 탐색하다가 (4,5)로 가야하는데 (3,6)으로 건너뛰는 케이스가 발생할 수 있기 때문  
    + 2배로 표시하면 위의 좌표가 테두리가 아니기 떄문에 방지 가능 
+ bfs 돌면서 테두리이면 탐색하는걸로 
+ 좌표가 아이템 좌표면 bfs 종료 

## 풀이
```java
import java.util.*; 

class Solution {
    static int[][] map = new int[101][101];
    public int solution(int[][] rectangle, int characterX, int characterY, int itemX, int itemY) {
        //int answer = 0;
        
        //int[][] map = new int[101][101];
        
        for(int i =0; i <rectangle.length; i++){
            int x1 = rectangle[i][0]; 
            int y1 = rectangle[i][1]; 
            int x2 = rectangle[i][2];
            int y2 = rectangle[i][3]; 
            
            draw(y1*2, x1*2, y2*2, x2*2);
        }
        
        return bfs(characterY*2,characterX*2,itemY*2,itemX*2);
    }
    
    public static int bfs(int Y,int X,int findY,int findX){
        int yy[]={-1,1,0,0};
        int xx[]={0,0,-1,1};
        
        Queue<Integer[]> queue=new LinkedList<>();
        queue.add(new Integer[]{Y,X,0});
        boolean visited[][]=new boolean[101][101];
        
        while(!queue.isEmpty()){
            Integer temp[]=queue.poll();
            int prevY=temp[0];
            int prevX=temp[1];
            int count=temp[2];
            
            if(prevY==findY&&prevX==findX)
                return count/2;
            
            for(int i=0;i<4;i++){
                int nextY=prevY+yy[i];
                int nextX=prevX+xx[i];
                if(nextY<0||nextX<0||nextY>=map.length||nextX>=map[0].length)
                    continue;
                if(visited[nextY][nextX]==true||map[nextY][nextX]!=2)
                    continue;
                
                visited[nextY][nextX]=true;
                queue.add(new Integer[]{nextY,nextX,count+1});
              
            }
        }
        
        return 0;
    }
    
    
    public static void draw(int y1,int x1,int y2,int x2){
        
        for(int i=y1;i<=y2;i++){
            for(int j=x1;j<=x2;j++){
            	if(map[i][j]== 1) continue; //이미 내부인 경우 
                map[i][j]= 1; //우선 내부로 
                if(i==y1||i==y2||j==x1||j==x2) //만약 테두리면 테두리로 변경 
                    map[i][j]= 2;
            }
        }
        
    }
}
```